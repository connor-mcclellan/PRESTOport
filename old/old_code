#    def rebin2(self):

#        new_bin_width = 2.0/(60.*24.) # days
#        time_series_length = np.max(self.data['bjd']) - np.min(self.data['bjd']) #days
#        n_bins = 2**np.ceil(np.log10(time_series_length / new_bin_width)/np.log10(2)).astype(int)
#        
#        new_flux = np.zeros(n_bins)
#        new_err = np.zeros(n_bins)

#        t0 = np.min(self.data['bjd'])
#        t_exp = self.exposure_time

#        binmarks = (t0 + new_bin_width*np.array(range(n_bins)) - 0.5*t_exp).astype(np.float64) # exposure time offset: center the bins around the timestamps
#        
#        print('Rebinning flux points...')
#        pb = ProgressBar(len(self.data['bjd']))

#        for i in range(len(self.data['bjd'])):
#            
#            # Rebin original flux data
#            timestamp = self.data['bjd'][i]
#            new_flux, new_err = split_flux(self.data['flux'][i], self.data['err'][i], timestamp, t_exp, new_bin_width, binmarks, new_flux, new_err)
#            
#            # Check for time gaps between this flux point and the next
#            gapstart = timestamp + 0.5*t_exp

#            if i+1 == len(self.data['bjd']):
#                gapend = binmarks[-1] + t_exp # very end of the rebinned time series
#            else:
#                gapend = self.data['bjd'][i+1] - 0.5*t_exp

#            gapwidth = gapend - gapstart
#            
#            # Value to replace gaps with
#            median_flux = np.median(self.data['flux'])
#            median_err = np.median(self.data['err'])

#            this_flux = median_flux*(gapwidth/t_exp)
#            this_err = median_err*(gapwidth/t_exp)

#            if gapwidth <= 0.:
#                pass
#            else:
#                # Now treat the gap as a data point with a flux value equal to the median, and rebin it into the new bins
#                effective_timestamp = 0.5*(gapstart + gapend)
#                new_flux, new_err = split_flux(this_flux, this_err, effective_timestamp, gapwidth, new_bin_width, binmarks, new_flux, new_err)

#            pb.update()

#        self.flux = new_flux
#        self.err = new_err

#        new_bjd = self.data['bjd'][0] + np.linspace(0, len(self.flux)*2./(60.*24.), len(self.flux))

#        self.data = Table([new_bjd, new_flux, new_err], names=['bjd', 'flux', 'err'], masked=True)


#    def rebin(self):
#       
#        
#        t_baseline = 2.0/(60.*24.) # minutes / (minutes/hr * hrs/day) = days
#        exp_baseline = 2.0/(60.*24.) # days
#        duration = np.max(self.data['bjd']) - np.min(self.data['bjd']) # days

#        float_bins = duration/t_baseline # unitless
#        power_round = np.round(np.log10(float_bins)/np.log10(2)+0.5).astype(int)
#        bins = 2**power_round

#        t0 = np.min(self.data['bjd']) # days
#        t = (np.arange(bins)*t_baseline)+t0 # days
#        rebinned_flux = np.zeros(bins)
#        rebinned_err = np.zeros(bins)
#        flux = self.data['flux']
#        err = self.data['err']

#        for i in range(len(self.data['bjd'])):
#            j = np.where(t <= self.data['bjd'][i])[0][-1]
#            k = np.where(t >= (self.data['bjd'][i]+exp_baseline))[0][0]

#            if j == k:
#                rebinned_flux[j] += flux[i]
#                rebinned_err[j] += err[i]
#            if k == (j+1):
#                frac1 = (t[j]+t_baseline-self.data['bjd'][i])/exp_baseline
#                rebinned_flux[j] += frac1*flux[i]
#                rebinned_err[j] += frac1*err[i]
#                frac2 = 1.0-frac1
#                rebinned_flux[k] += frac2*flux[i]
#                rebinned_err[k] += frac2*err[i]

#            if k == (j+2):
#                frac1 = (t[j]+t_baseline-self.data['bjd'][i])/exp_baseline
#                rebinned_flux[j] += frac1*flux[i]
#                rebinned_err[j] += frac1*err[i]
#                frac2 = (t_baseline/exp_baseline)
#                rebinned_flux[j+1] += frac2*flux[i]
#                rebinned_err[j+1] += frac2*err[i]
#                frac3 = 1.0-(frac1+frac2)
#                rebinned_flux[k] += frac3*flux[i]
#                rebinned_err[k] += frac3*err[i]

#        t -= t0
#        self.flux = rebinned_flux
#        self.err = rebinned_err

#        new_bjd = self.data['bjd'][0] + np.linspace(0, len(self.flux)*2./(60.*24.), len(self.flux))
#        new_flux = rebinned_flux
#        new_err = rebinned_err

#        self.data = Table([new_bjd, new_flux, new_err], names=['bjd', 'flux', 'err'], masked=True)

#        return rebinned_flux, rebinned_err

#    def chisqnu_flux(self, plot=True):
#        
#        try:
#            flux_array = self.flux
#            err_array = self.err
#        except AttributeError:
#            flux_array, err_array = self.rebin()
#        
#        nonzero = np.where(flux_array != 0.)
#        flux_array = flux_array[nonzero] * 1e7
#        err_array = err_array[nonzero] * 1e7
#        x = np.linspace(0, len(flux_array) - 1, len(flux_array))

#        z = np.polyfit(x, flux_array, 1)
#        chsq = np.sum(((flux_array - np.polyval(z, x)) ** 2.)/err_array**2.)/(len(flux_array)-1)
#        p = np.poly1d(z)

#        if plot:
#            fig = plt.figure()
#            ax = fig.add_subplot(111)
#            ax.errorbar(x, flux_array, yerr=err_array, ms=2, fmt='ko', elinewidth=.5, alpha=0.5)
#            ax.plot(x, p(x), 'b--')
#            ax.set_xlabel('Index')
#            ax.set_ylabel('Flux (1e-7)')
#            ax.text(0.1, 0.9, "Reduced Chi Squared: %.4f" % chsq, transform=ax.transAxes)
#            plt.show()

#        return chsq


#def split_flux(og_flux, og_err, timestamp, t_exp, new_bin_width, binmarks, new_flux, new_err):
#    """
#    Split an original data point at a certain timestamp into its 
#    appropriate new flux bins.

#    Parameters
#    ----------
#    og_flux : scalar
#        The flux value of the original data point.
#    og_err : scalar
#        The error value of the original data point.
#    timestamp : scalar
#        The BJD of the original data point.
#    t_exp : scalar
#        The exposure time corresponding to a single data point.
#    new_bin_width: scalar
#        The width (in days) of the new bins.
#    binmarks : array
#        An array of the timestamps at the beginning of each new bin.
#    new_flux : array
#        The array into which the rebinned flux is to be distributed. This
#        array is changed by this function.
#    new_err : array
#        The array into which the rebinned error is to be distributed. This
#        array is changed by this function.
#    """    

#    t_L = timestamp-0.5*t_exp # Start time of original flux bin
#    t_R = timestamp+0.5*t_exp # End time of original flux bin

#    # Get time of closest bin marker before timestamp-0.5*t_exp
#    binmark_left = binmarks[t_L >= binmarks][-1]

#    # Get time of closest new bin marker after timestamp+0.5*t_exp
#    try:
#        binmark_right = binmarks[t_R <= binmarks][0]
#    except IndexError:
#        binmark_right = binmarks[-1]
#    n = np.ceil((binmark_right - binmark_left)/new_bin_width).astype(int) # number of new bins that the old bin will be divided into

#    # Split up flux into each of the new bins

#    n_middle = n-2 # number of bins between the left and right bin

#    if n_middle < 0:
#        # then timestamp spans only a single bin. Dump it all into that bin.
#        index = np.where(binmarks == binmark_left)[0][0]
#        new_flux[index] += og_flux
#        new_err[index] += og_err

#    elif n_middle == 0:

#        # Leftmost flux bin
#        index_left = np.where(binmarks == binmark_left)[0][0] # index of binmark left
#        frac_L = (binmarks[index_left + 1] - (timestamp - 0.5*t_exp))/new_bin_width
#        new_flux[index_left] += frac_L*og_flux
#        new_err[index_left] += frac_L*og_err
#        
#        # Rightmost flux bin
#        index_right = np.where(binmarks == binmark_right)[0][0] # index of binmark right
#        frac_R = ((timestamp + 0.5*t_exp) - binmarks[index_right - 1])/new_bin_width
#        new_flux[index_right - 1] += frac_R*og_flux
#        new_err[index_right - 1] += frac_R*og_err

#    else:
#        # Leftmost flux bin
#        index_left = np.where(binmarks == binmark_left)[0][0] # index of binmark left
#        frac_L = (binmarks[index_left + 1] - (timestamp - 0.5*t_exp))/new_bin_width
#        new_flux[index_left] += frac_L*og_flux
#        new_err[index_left] += frac_L*og_err
#        
#        # Rightmost flux bin
#        index_right = np.where(binmarks == binmark_right)[0][0] # index of binmark right
#        frac_R = ((timestamp + 0.5*t_exp) - binmarks[index_right - 1])/new_bin_width
#        new_flux[index_right - 1] += frac_R*og_flux
#        new_err[index_right - 1] += frac_R*og_err 

#        # Middle bins
#        for middlebin in binmarks[range(index_left + 1, index_left + 1 + n_middle)]:
#            index_middle = np.where(binmarks == middlebin)[0][0]
#            frac_remainder = (1. - (frac_R + frac_L))/n_middle
#            new_flux[index_middle] += frac_remainder*og_flux
#            new_err[index_middle] += frac_remainder*og_err
#    
#    return new_flux, new_err

